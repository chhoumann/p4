\section{Unit Testing}
In implementing unit testing, we have followed a few approaches.
In general, we have attempted to follow the Act-Arrange-Assert (AAA)
methodology, as well as the naming convention 
\texttt{MethodName\_Scenario\_ExpectedResult}.

We did not use Test-Driven Development, instead resorting to testing
when we've finished the implementation of each part. While not ideal, it
contributed to us catching bugs and fixing errors that we wouldn't
otherwise have caught.

To illustrate our approach to testing, we will draw examples from our
AST Builder tests.

Our approach is to traverse the AST through a visitor. First,
we had the test fixture class inherit from an AST visitor interface.
Then we implemented traversal between nodes, where each node knows how
to visit the node(s) below.

To test the visitor, we wrote some test code in \dazel{}, which can be seen in \snipref{lst:asttestcode}. We made sure that
the test fixture class could load this test code and generate a parse
tree from it.

In each \texttt{Visit} method, we call \texttt{Assert} which tests
that the node contains the correct information in relation to the
aforementioned \dazel{} test code.

For example, the visit to a \texttt{GameObject} checks that it has the
right type (line \ref{code:stcheck}), identifier (line \ref{code:sicheck}), and contents (line \ref{code:sccheck}). Then it goes on to check that
\texttt{GameObjectContent} are of the right types, and that they have
correct amount of statements in their scopes. Lastly, it starts visiting
those such that a similar process can happen to the remaining nodes (line \ref{code:sprocc}).

\begin{lstlisting}[caption={AST Builder \dazel{} test code}, label={lst:asttestcode}]
    "Screen SampleScreen1" + // Test GameObject
    "{" +
    "   Map" + // Test GameObjectContent & GameObjectContentType
    "   {" +
    "       Size(30, 24);" + // Test function invocation
    "       SomeVar1 = 2.0;" + // Test assignment & floats
    "       { " + // Test statement block
    "           SomeVar2 = 3 + 3 / 3;" + // Test expressions & integers
    "           x = SomeVar2;" + // Test identifier values
    "       }" +
    "       let = SampleScreen1.Exits.exit1;" + // Test member access 
    "       arr = [1, 2, 3];" + // Test arrays
    "   }" +
    "" +
    "   Entities" +
    "   {" +
    "       SpawnEntity(Skeleton1, [4, 5]);" +
    "   }" +
    "}";
    \end{lstlisting}


\begin{lstlisting}[caption={GameObject visitor code for testing the AST Builder}, label={lst:gameobjecttest},escapechar=|, language=CSharp]
public void Visit(GameObject gameObject)
{
    // Line 1
    Assert.That(gameObject.Type is Screen, "gameObject.Type is ScreenType");|\label{code:stcheck}|
    Assert.That(gameObject.Identifier == "SampleScreen1", "gameObject.Identifier == 'SampleScreen1'");|\label{code:sicheck}|
    
    // Contents: Map, Entities|\label{code:sccheck}|
    Assert.That(gameObject.Contents[0].Type is MapType, "gameObject.Contents[0].Type is MapType");
    Assert.That(gameObject.Contents[1].Type is EntitiesType, "gameObject.Contents[1].Type is EntitiesType");

    // Map has 12 top-level statements (some statement blocks have nested statements)|\label{code:smtcheck}|
    Assert.That(gameObject.Contents[0].Statements.Count == 5, $"gameObject.Contents[0].Statements.Count == 5." + $"Found {gameObject.Contents[0].Statements.Count}");
    
    // Entities has 1 top-level statement|\label{code:semtcheck}|
    Assert.That(gameObject.Contents[1].Statements.Count == 1, $"gameObject.Contents[1].Statements.Count == 1" + $"Found {gameObject.Contents[1].Statements.Count}");
    
    gameObject.Contents.ForEach(Visit);|\label{code:sprocc}|
}
\end{lstlisting}

Besides verifying that we build a correct AST, it is crucial to test the semantical analysis that the \dazel{} interpreter performs. Therefore, we have written tests with different \dazel{} test code for each test. These tests are largely focused on type checking and scope checking.

Again, to illustrate, we will draw from example. In code \snipref{lst:ArrayPlusIntegerFails}, the test builds an AST for the code in \texttt{TestCode2} and begins typechecking.

Because of the test code, an \texttt{InvalidOperationException} is thrown, which would be expected due to the illegal operation on line \ref{code:illegalcode1}.

\begin{lstlisting}[caption={Testing that arrays and integers cannot be added together}, label={lst:ArrayPlusIntegerFails}, language=CSharp, escapechar=|]
private const string TestCode2 =
    "Screen SampleScreen1" +
    "{" +
    "   Map" +
    "   {" +
    "       arr = [1, 2, 3] + 3;" +|\label{code:illegalcode1}|
    "   }" +
    "" +
    "}";

[Test]
public void TypeCheck_Visit_ArrayPlusIntegerFails()
{
    AbstractSyntaxTree ast = BuildAst(TestCode2);
    TypeChecker tc = new(ast);

    void TestDelegate() => tc.Visit(ast.Root.GameObjects["SampleScreen1"]);
    Assert.Throws<InvalidOperationException>(TestDelegate);
}
\end{lstlisting}

The remaining type checker tests are similar to the one seen in \snipref{lst:ArrayPlusIntegerFails}.