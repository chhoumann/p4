\section{Building the Abstract Syntax Tree}

Following the parsing phase, and given that there are no errors in the source code that violate the syntax rules, the construction of the abstract syntax tree (AST) will begin. The construction of the AST is achieved through the use of a visitor pattern, more specifically, a technique called double dispatch. The benefit of using this technique is that it gives the ability to separate algorithms from the objects on which they operate\cite{VisitorGuru}. 

As is typical with a visitor pattern there is a client which is responsible for running the visitor operations by directing the appropiate operation in the visitor object through an accept method. In our case the client is the \textbf{Run()} method found in the class DazelCompiler. The definition for the for the method can be seen in \snipref{lst:RunMethod}.

\begin{lstlisting}[caption={The Run method that serves as a client inside the DazelCompiler class}, label={lst:RunMethod},escapechar=|]
    public IEnumerable<ScreenModel> Run()
    {
            ...

            IEnumerable<IParseTree> parseTrees = BuildParseTrees(); |\label{line:ParseTreeBuilder}|

            AbstractSyntaxTree ast = new AstBuilder().BuildAst(parseTrees); |\label{line:ASTBuilder}|

            ...
    }
\end{lstlisting}

As can be seen on line \ref{line:ParseTreeBuilder} the initial step for the client is to run the lexical and parse phase which produces a parse tree. This is executed by the code produced by Antlr as mentioned in \ref{sec:antlrTool}. Once this phase is completed the result, the parse tree, is saved in the variable \textbf{parseTrees} and passed through to the \textbf{BuildAst} method on line \ref{line:ASTBuilder}. 
The method is then what is responsible for starting the visiting process based on the parse tree that was passed through the parameter. The definition for the \textbf{BuildAst} method can be seen in \snipref{lst:BuildAstMethod}.

\begin{lstlisting}[caption={The BuildAst method}, label={lst:BuildAstMethod},escapechar=|]
    public AbstractSyntaxTree BuildAst(IEnumerable<IParseTree> parseTrees)
        {
            Dictionary<string, GameObjectNode> gameObjects = new Dictionary<string, GameObjectNode>(); |\label{line:GODictionary}|
            
            foreach (IParseTree parseTree in parseTrees) |\label{line:ParseForeach}|
            {
                DazelParser.GameObjectContext gameObjectContext = parseTree.GetChild(0) as DazelParser.GameObjectContext; |\label{line:GetParseChild}|
                GameObjectNode gameObjectNode = VisitGameObject(gameObjectContext); |\label{line:VisitGO}|
                
                gameObjects.Add(gameObjectNode.Identifier, gameObjectNode); |\label{line:ASTToDict}|
            }

            RootNode root = new RootNode() |\label{line:newRoot}|
            {
                GameObjects = gameObjects
            };
            
            return new AbstractSyntaxTree(root); |\label{line:CombinedAST}|
        }
\end{lstlisting}

At the root of every parse tree is a \textbf{GameObject}. A \textbf{GameObject} in \dazel{} specifies an object, which content should be displayed inside the game in the final output. Each \textbf{GameObject} represents a text file that contains source code to be compiled. This means that there could be multiple text files, each specifying some content for the final output and therefore multiple parse trees. 
The consequence of this structure is that the compiler has to build an AST for each of the parse trees and finally produce a single AST by combining them with a single root. On line \ref{line:ParseForeach} in the foreach loop, is where the process of visiting each parse tree starts. 
The intial step of each iteration is to find and store each parse in a variable called \textbf{gameObjectContext}. The root of every parse tree is a \textbf{GameObject} which is the first child of every tree. This can be seen on line \ref{line:ParseForeach} through the \texttt{parseTree.GetChild(0)} method call.
Once the \textbf{GameObject} has been assigned to \textbf{gameObjectContext} the visitor is called on that given \textbf{gameObject} on line \ref{line:VisitGO} and an AST is produced. 
In order to maintain the AST's for each iteration, we add them to a dictionary which can be seen on line \ref{line:ASTToDict}. 
Note that a list structure could have been used to store the AST's, but we chose dictionaries for the faster lookup.

Once all the individual AST's have been produced, they are combined by giving them a common root node on line \ref{line:newRoot} and a combined AST, with the new root is created on line \ref{line:CombinedAST}.
 
\subsubsection*{Visiting the Game Object}
In the following, we will further describe how the \textbf{VisitGameObject} method from \snipref{lst:BuildAstMethod} on line \ref{line:VisitGO} works and how the over all visitor pattern comes into play.










