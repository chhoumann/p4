\section{Building the Abstract Syntax Tree} \label{sec:buildASTSection}

Following the parsing phase, and given that there are no errors in the source code that violate the syntax rules, the construction of the abstract syntax tree (AST) will begin. The construction of the AST is achieved through the use of a visitor pattern, more specifically, a technique called double dispatch. The benefit of using this technique is that it gives the ability to separate algorithms from the objects on which they operate\cite{VisitorGuru}. 

As is typical with a visitor pattern there is a client which is responsible for running the visitor operations by directing the appropiate operation in the visitor object through an accept method. In our case the client is the \textbf{TryRun} method found in the class DazelCompiler. The definition for the for the method can be seen in \snipref{lst:RunMethod}.

\begin{lstlisting}[language=CSharp, caption={The Run method that serves as a client inside the DazelCompiler class}, label={lst:RunMethod},escapechar=|]
public bool TryRun(out IEnumerable<ScreenModel> screenModels)
{
    ...

    IEnumerable<IParseTree> parseTrees = BuildParseTrees(); |\label{line:ParseTreeBuilder}|

    AbstractSyntaxTree ast = new AstBuilder().BuildAst(parseTrees); |\label{line:ASTBuilder}|

    ...
}
\end{lstlisting}

As can be seen on line \ref{line:ParseTreeBuilder} in \Snipref{lst:RunMethod} the initial step for the client is to run the lexical and parse phase which produces a parse tree. This is executed by the code produced by Antlr as mentioned in \ref{sec:antlrTool}. Once this phase is completed the result, the parse tree, is saved in the variable \textbf{parseTrees}, and an object of type \textbf{AstBuilder} is instantiated on which the \texttt{BuildAst} method is invoked with the parse tree. This class implements a visitor interface which defines methods for visiting the parse tree nodes. Through these method implementations, the \textbf{AstBuilder} can traverse the parse tree from which it constructs the abstract syntax tree nodes which can be seen on line \ref{line:ASTBuilder}. 

The definition for the \textbf{BuildAst} method can be seen in \snipref{lst:BuildAstMethod}.

\begin{lstlisting}[language=CSharp, caption={The BuildAst method}, label={lst:BuildAstMethod},escapechar=|]
public AbstractSyntaxTree BuildAst(IEnumerable<IParseTree> parseTrees)
{
    Dictionary<string, GameObjectNode> gameObjects = new Dictionary<string, GameObjectNode>(); |\label{line:GODictionary}|
    
    foreach (IParseTree parseTree in parseTrees) |\label{line:ParseForeach}|
    {
        DazelParser.GameObjectContext gameObjectContext = parseTree.GetChild(0) as DazelParser.GameObjectContext; |\label{line:GetParseChild}|
        GameObjectNode gameObjectNode = VisitGameObject(gameObjectContext); |\label{line:VisitGO}|
        
        gameObjects.Add(gameObjectNode.Identifier, gameObjectNode); |\label{line:ASTToDict}|
    }

    RootNode root = new RootNode() |\label{line:newRoot}|
    {
        GameObjects = gameObjects
    };
    
    return new AbstractSyntaxTree(root); |\label{line:CombinedAST}|
}
\end{lstlisting}

At the root of every parse tree is a \textbf{GameObject}. A \textbf{GameObject} in \dazel{} specifies an object whose content should be displayed in the final output - that is, the game. Each \textbf{GameObject} represents a text file that contains source code to be compiled. This means that there could be multiple text files, each specifying different \textbf{GameObjects} for the game and therefore multiple parse trees. 
The consequence of this structure is that the compiler has to build an AST for each parse tree. The process of visiting each parse tree can be seen on line \ref{line:ParseForeach} in the foreach loop. 
The intial step of each iteration is to visit the \textbf{GameObjectContext} which contains the content of the \textbf{GameObject}.
Then, through dynamic dispatch, the \textbf{AstBuilder} visits every node in the parse tree from which it then contructs and connects the nodes present in the given AST.
After being fully built, each AST is stored in a dictionary which can be seen on line \ref{line:ASTToDict}. 
This dictionary is used to connect every individual AST to a single root node after every AST has been built, which can be seen on line \ref{line:newRoot}. Thus we ultimately end up with one big AST which is returned to the caller on line \ref{line:CombinedAST}. Note that a list structure could have been used to store the ASTs, but we chose dictionaries for the faster lookup.
 
\subsubsection*{Visiting the GameObject}
In the following, we will further describe how the \textbf{VisitGameObject} method from \snipref{lst:BuildAstMethod} on line \ref{line:VisitGO} works and how the overall visitor pattern comes into effect.

As \textbf{VisitGameObject} is called with a parse tree, the initial step is to perform pattern matching on the type of \textbf{GameObject} which can be seen in the definition for \texttt{VisitGameObject} on line \ref{line:PatternMatch} in \snipref{lst:VisitParseTree}. This is done to ensure that the parsed source code contains a correct \textbf{GameObject} type and create a node of either of the legal types, which is then assigned to the local variable \texttt{typeNode}.

Once the pattern matching is done, we use object initialization to create a new \textbf{GameObjectNode} on line \ref{line:NewGONode}. In the initialization of this object, we call the \texttt{VisitGameObjectContents} method on line \ref{line:VisitGameObjectContents}, which is where the cascading effect of the visitor pattern begins. 

\begin{lstlisting}[language=CSharp, caption={The initial stage of visiting}, label={lst:VisitParseTree},escapechar=|]
public GameObjectNode VisitGameObject(DazelParser.GameObjectContext context)
{
    GameObjectTypeNode typeNode;
    
    switch (context.gameObjectType.Type) |\label{line:PatternMatch}|
    {
        case DazelLexer.SCREEN:
            typeNode = new ScreenNode();
            break;
        case DazelLexer.ENTITY:
            typeNode = new EntityNode();
            break;
        case DazelLexer.MOVE_PATTERN:
            typeNode = new MovePatternNode();
            break;
        default:
            throw new ArgumentException("Type is not a GameObjectType!");
    }

    GameObjectNode gameObjectNode = new GameObjectNode() |\label{line:NewGONode}|
    {
        Token = context.Start,
        Identifier = context.GetChild(1).GetText(),
        TypeNode = typeNode,
        Contents = VisitGameObjectContents(context.gameObjectBlock().gameObjectContents()) |\label{line:VisitGameObjectContents}|
    };
    
    return gameObjectNode;
}
\end{lstlisting}

An example of a visit method can be seen in \snipref{lst:VisitAssignment}.
Here, the visitor instantiates and returns an AssignmentNode whose \texttt{Identifier} property is assigned to the text from the identifier terminal node in the parse tree. 
This corresponds to the left hand side of the assignment and can be seen on line \ref{line:GetId}. In addition, in the object instantiation, the \texttt{VisitExpression} method is called on line \ref{line:VisitExpr} to continue visiting all elements of the right hand side of the assignment. Once the terminal nodes for the expression are visited, they will be assigned to the \textbf{Expression} property of the assignment. At this point in the code compilation, the expression may consist of illegal operations such as adding objects to integers, however the \textbf{AstBuilder} is not concerned with types and expression evaluation. The legality of expressions is checked later in the \textbf{TypeChecker} described in section \ref{sec:TypeChecker}.

\begin{lstlisting}[language=CSharp, caption={Visit assignment}, label={lst:VisitAssignment},escapechar=|]
public StatementExpressionNode VisitAssignment(DazelParser.AssignmentContext context)
{
    return new AssignmentNode()
    {
        Token = context.Start,
        Identifier = context.IDENTIFIER().GetText(), |\label{line:GetId}|
        Expression = VisitExpression(context.expression()) |\label{line:VisitExpr}|
    };
}
\end{lstlisting}

The strategy for all the rest of the visitor methods follow the same mode of logic, where if a terminal node has been found, it is saved and if a non terminal node has been found, it continues to visit the parse tree until it finds all the terminal nodes in the tree.

Following the construction if the AST the semantic analysis of the compiler can begin, which consists of type checking, scope checking as well as the evaluation of expressions.
