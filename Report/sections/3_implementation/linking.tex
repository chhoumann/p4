\subsection*{Member Access Linking} \label{sec:Linker}
Since the beginning of the project, one of the largest tasks was figuring out how to connect screens together, both syntacically and semantically. 
As mentioned in chapter \ref{chap:language_design}, we decided to link screens together by allowing access to other screens and their variables through member access. 


Two examples of member access can be seen in \snipref{lst:LinkingExample}. 
On line \ref{line:MemberAccessExample1}, \texttt{Exit1} in \texttt{SampleScreen1} is being connected to \texttt{Exit1} in \texttt{SampleScreen2} through member access in the \texttt{Exit} function invocation.
Similarly, on line \ref{line:MemberAccessExample2}, \texttt{Exit1} in \texttt{SampleScreen2} is being connected to \texttt{Exit1} in \texttt{SampleScreen1}.

\begin{lstlisting}[language=CSharp, caption={\dazel{} source code example of member access.}, label={lst:LinkingExample},escapechar=|]
// ./src/SampleScreen1.txt
Screen SampleScreen1 
{
	Map 
	{
		Size(30, 24);
		Floor("Grass");
	}
	
	Exits 
	{
		Exit1 = Exit([8, 2], SampleScreen2.Exits.Exit1); |\label{line:MemberAccessExample1}|
	}
}

// ./src/SampleScreen2.txt
Screen SampleScreen2
{
	Map 
	{
		Size(40, 40);
		Floor("Stone");
	}
	
	Exits 
	{
		Exit1 = Exit([4, 0], SampleScreen1.Exits.Exit1); |\label{line:MemberAccessExample2}|
	}
}
\end{lstlisting}

It is worth noting that all screens and objects defined within a screen are always accessible from the outside, and that member access is currently restricted to \texttt{Exit} types.


To illustrate how member access is implemented in \dazel{}, we will first highlight the \textbf{LinkChecker} class whose responsibility to check the legality of member access nodes. This is done directly after type checking.
As with previous examples, the \textbf{LinkChecker} class implements a visitor pattern to traverse the AST.
Once the \textbf{LinkChecker} encounters a function invocation with member access through traversal of the AST, it will first verify that the referenced \textbf{GameObject} is valid. 
If the \textbf{GameObject} is valid, it will check if any of the parameters is a member access node and, if so, traverse them. This can be seen in the function invocation visit method on lines \ref{line:VisitFunctionInvocationStart} to \ref{line:VisitFunctionInvocationEnd}. 

\begin{lstlisting}[language=CSharp, caption={linker}, label={lst:LinkerClass},escapechar=|]
public sealed class LinkChecker : ICompleteVisitor
{
	... 

	public void Visit(FunctionInvocationNode functionInvocationNode) |\label{line:VisitFunctionInvocationStart}|
	{
		switch (functionInvocationNode.Function) 
		{
			case ScreenExitFunction screenExitFunction:
			{
				if (!abstractSyntaxTree.TryRetrieveGameObject(screenExitFunction.ConnectedScreenIdentifier))
				{
					DazelLogger.EmitError($"Screen {string.Join(".", screenExitFunction.ConnectedScreenIdentifier)} does not exist", functionInvocationNode.Token);
				}
				break;
			}
			case ExitFunction exitFunction:
				exitFunction.MemberAccessNode.Accept(this);
				break;
			
			...
		}

		foreach (ValueNode valueNode in functionInvocationNode.Parameters)
		{
			if (valueNode is MemberAccessNode memberAccessNode)
			{
				memberAccessNode.Accept(this);
			}
		}
	} |\label{line:VisitFunctionInvocationEnd}|

	...

	public void Visit(MemberAccessNode memberAccessNode)
	{
		var calc = new NoOpCalculator<NoOpCalculator<ValueNode>>(memberAccessNode.Token);
		
		new ExpressionEvaluatorLinker<NoOpCalculator<ValueNode>>(calc).Visit(memberAccessNode);
	}
	
	...

	public void Visit(ExitValueNode exitValueNode)
	{
		if (exitValueNode is TileExitValueNode tileExit)
		{
			EnvironmentStore.AccessMember(tileExit.ToExit);
		} 

		...
	}	
}
\end{lstlisting}

When the \textbf{LinkChecker} visits a members access node \fxfatal{Describe visit member access node and exit value node}



\begin{lstlisting}[language=CSharp, caption={Visit assignment}, label={lst:VisitAssignment},escapechar=|]
namespace Dazel.Compiler.SemanticAnalysis
{
	public abstract class EnvironmentStore
	{
		|\dots|

		private static readonly Dictionary<string, SymbolTable> TopSymbolTables = new Dictionary<string, SymbolTable>();
		
		|\dots|

		public static VariableSymbolTableEntry AccessMember(List<string> identifierList)
		{
			string symbolIdentifier = identifierList[identifierList.Count - 1];
			
			SymbolTable symbolTable = TopSymbolTables[identifierList[0]];
			SymbolTableEntry symbolTableEntry = symbolTable.RetrieveSymbolInChildScope(symbolIdentifier);

			if (symbolTableEntry is VariableSymbolTableEntry variableSymbolTableEntry)
			{
				return variableSymbolTableEntry;
			}
			
			return null;
		}
	}
}
\end{lstlisting}

