\subsection*{Member Access Linking} \label{sec:Linker}
Since the beginning of the project, one of the largest tasks was figuring out how to connect screens together, both syntacically and semantically. 
As mentioned in chapter \ref{chap:language_design}, we decided to link screens together by allowing access to other screens and their variables through member access. 


Two examples of member access can be seen in \snipref{lst:LinkingExample}. 
On line \ref{line:MemberAccessExample1}, \texttt{Exit1} in \texttt{SampleScreen1} is being connected to \texttt{Exit1} in \texttt{SampleScreen2} through member access in the \texttt{Exit} function invocation.
Similarly, on line \ref{line:MemberAccessExample2}, \texttt{Exit1} in \texttt{SampleScreen2} is being connected to \texttt{Exit1} in \texttt{SampleScreen1}.

\begin{lstlisting}[language=CSharp, caption={\dazel{} source code example of member access.}, label={lst:LinkingExample},escapechar=|]
// ./src/SampleScreen1.txt
Screen SampleScreen1 
{
	Map 
	{
		Size(30, 24);
		Floor("Grass");
	}
	
	Exits 
	{
		Exit1 = Exit([8, 2], SampleScreen2.Exits.Exit1); |\label{line:MemberAccessExample1}|
	}
}

// ./src/SampleScreen2.txt
Screen SampleScreen2
{
	Map 
	{
		Size(40, 40);
		Floor("Stone");
	}
	
	Exits 
	{
		Exit1 = Exit([4, 0], SampleScreen1.Exits.Exit1); |\label{line:MemberAccessExample2}|
	}
}
\end{lstlisting}

It is worth noting that all screens and objects defined within a screen are always accessible from the outside, and that member access is restricted to specific types such as the \texttt{Exit} type.


To illustrate how member access is implemented in \dazel{}, we will first highlight the \textbf{LinkChecker} class whose responsibility to check the legality of member access nodes. This is done directly after type checking.
As with previous examples, the \textbf{LinkChecker} class implements a visitor pattern to traverse the AST.

function invocation (exit)
envsto 


\begin{lstlisting}[language=CSharp, caption={Visit assignment}, label={lst:VisitAssignment},escapechar=|]
namespace Dazel.Compiler.SemanticAnalysis
{
	public abstract class EnvironmentStore
	{
		|\dots|

		private static readonly Dictionary<string, SymbolTable> TopSymbolTables = new Dictionary<string, SymbolTable>();
		
		|\dots|

		public static VariableSymbolTableEntry AccessMember(List<string> identifierList)
		{
			string symbolIdentifier = identifierList[identifierList.Count - 1];
			
			SymbolTable symbolTable = TopSymbolTables[identifierList[0]];
			SymbolTableEntry symbolTableEntry = symbolTable.RetrieveSymbolInChildScope(symbolIdentifier);

			if (symbolTableEntry is VariableSymbolTableEntry variableSymbolTableEntry)
			{
				return variableSymbolTableEntry;
			}
			
			return null;
		}
	}
}
\end{lstlisting}

\begin{lstlisting}[language=CSharp, caption={linker}, label={lst:LinkerClass},escapechar=|]
public sealed class LinkChecker : ICompleteVisitor
{
	... 

    public void Visit(FunctionInvocationNode functionInvocationNode)
    {
        switch (functionInvocationNode.Function)
        {
            case ScreenExitFunction screenExitFunction:
            {
                if (!abstractSyntaxTree.TryRetrieveGameObject(screenExitFunction.ConnectedScreenIdentifier))
                {
                    DazelLogger.EmitError($"Screen {string.Join(".", screenExitFunction.ConnectedScreenIdentifier)} does not exist", functionInvocationNode.Token);
                }
                break;
            }
            case ExitFunction exitFunction:
                exitFunction.MemberAccessNode.Accept(this);
                break;
			
			...
        }

        foreach (ValueNode valueNode in functionInvocationNode.Parameters)
        {
            if (valueNode is MemberAccessNode memberAccessNode)
            {
                memberAccessNode.Accept(this);
            }
        }
    }

	...

    public void Visit(MemberAccessNode memberAccessNode)
    {
        var calc = new NoOpCalculator<NoOpCalculator<ValueNode>>(memberAccessNode.Token);
     
        new ExpressionEvaluatorLinker<NoOpCalculator<ValueNode>>(calc).Visit(memberAccessNode);
    }
	
	...

    public void Visit(ExitValueNode exitValueNode)
    {
        if (exitValueNode is TileExitValueNode tileExit)
        {
            EnvironmentStore.AccessMember(tileExit.ToExit);
        } 

		...
    }	
}
\end{lstlisting}