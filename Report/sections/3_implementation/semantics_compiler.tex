\section{Performing semantic analysis}

Once the AST has been constructued the next phase of the compiler is to perform semantic analysis. From the same client method \texttt{Run()} seen in \snipref{lst:RunMethod} the semantic analysis is performed. This is done through the \texttt{PerformSemanticAnalysis(ast)} method. 
Similar to previously \texttt{PerformSemanticAnalysis(ast)} in \snipref{lst:RunMethodSecond} starts a visitor sequence on the built AST that is stored in the variable \textbf{ast} seen on \ref{line:ASTSavedInVar}. This is done by passing the AST through the parameter of \texttt{PerformSemanticAnalysis(ast)} seen on line \ref{line:PerformSemAna}.

\begin{lstlisting}[caption={The Run method that serves as a client inside the DazelCompiler class}, label={lst:RunMethodSecond},escapechar=|]
    public IEnumerable<ScreenModel> Run()
    {
        AbstractSyntaxTree ast = new AstBuilder().BuildAst(parseTrees); |\label{line:ASTSavedInVar}|

        ...
        
        PerformSemanticAnalysis(ast); |\label{line:PerformSemAna}|

        ...
    }
\end{lstlisting}

During the visititation of the AST both scope checking and type checking is done simultaniously. 
In order to accommodate the ability to perform checking for both at the same time we implemented an abstract class \textbf{SemanticAnalysis}. The purpose of this class is to implement a stack which can be seen on line \ref{line:Stack} that can hold a symbol table for each frame in the stack. The benefit of this approach is that each scope will be a symbol table on the stack and therefore the inner most nested scopes will always be at the top of the stack. This allows us to enforce static scoping by referencing the symbol tables further down the stack for existing declarations.

The definition of this abstract class can be seen in \snipref{lst:ACSemanticAnalysis}.

\begin{lstlisting}[caption={Abstract class SemanticAnalysis}, label={lst:ACSemanticAnalysis},escapechar=|]
    public abstract class SemanticAnalysis
    {
        public readonly Stack<SymbolTable<SymbolTableEntry>> EnvironmentStack = new Stack<SymbolTable<SymbolTableEntry>>(); |\label{line:Stack}|

        protected void OpenScope()
        {
            SymbolTable<SymbolTableEntry> parentScope = EnvironmentStack.Count > 0 ? EnvironmentStack.Peek() : null; |\label{line:IsStackEmpty}|
            SymbolTable<SymbolTableEntry> newScope = new SymbolTable<SymbolTableEntry>(parentScope);
            
            EnvironmentStack.Push(newScope); |\label{line:PushNewScopeToStack}|
        }

        protected void CloseScope()
        {
            EnvironmentStack.Pop();
        }
    }
\end{lstlisting}

The two methods \texttt{OpenScope()} and \texttt{CloseScope()} are each responsible for handling the push and pop actions for the stack respectively.
\texttt{OpenScope()} has two responsibilities. First of which is to check if the stack is empty. In case it is not empty, whatever value is currently at the top of the stack should become the parent of the next value on the stack. This way we ensure that there always is access to the previous scopes when the scope checking is performed at a later stage. This can be seen on line \ref{line:IsStackEmpty} to \ref{line:PushNewScopeToStack}.