\section{Code Generation} \label{sec:code_generation}
As a result of the semantic analysis phase, the \dazel{} compiler is ready to undertake the 'Code Generation' phase.
This phase, for \dazel{}, primarily deals with generating intermediate models. These models are used in the \dazel{} game.

A such model is the \texttt{ScreenModel}\ref{lst:screenmodel}.

\begin{lstlisting}[language=CSharp, label={lst:screenmodel}, caption={ScreenModel}]
public sealed class ScreenModel
{
    public Stack<IGenerator> TileStack { get; set; } = new Stack<IGenerator>();
    public List<EntityModel> Entities { get; set; } = new List<EntityModel>();
    public List<ScreenExitModel> ScreenExits { get; set; } = new List<ScreenExitModel>();
    public List<TileExitModel> TileExits { get; set; } = new List<TileExitModel>();

    public int Width { get; set; }
    public int Height { get; set; }
    
    public string Identifier { get; }

    public ScreenModel(string identifier)
    {
        Identifier = identifier;
    }
}
\end{lstlisting}

A \texttt{ScreenModel}\ref{lst:screenmodel} is generated by a \texttt{ScreenGenerator}.

In the constructor for a \texttt{ScreenGenerator}, a \texttt{GameObjectNode} is passed in. Here, the contents and identifier of the game object is saved in private fields to the \texttt{ScreenGenerator}. This is also where it instantiates a new \texttt{ScreenModel}, which will later be assigned values based on data in the game object.  

This generator traverses the AST in a depth-first manner using a visitor. It traverses until it reaches a \texttt{FunctionInvocationNode} or \texttt{ExitValueNode}.

Once it reaches a \texttt{FunctionInvocationNode}, it will add certain data to the \texttt{ScreenModel}, depending on which \texttt{FunctionInvocationNode} was reached\ref{lst:finVisitSG}.

\begin{lstlisting}[language=CSharp, caption={FunctionInvocationNode Visit method}, label={lst:finVisitSG}]
public void Visit(FunctionInvocationNode functionInvocationNode)
{
    switch (functionInvocationNode.Function)
    {
        case SizeFunction sizeFunction:
            screenModel.Width = sizeFunction.Width;
            screenModel.Height = sizeFunction.Height;
            break;
        case FloorFunction floorFunction:
            screenModel.TileStack.Push(new Floor(screenModel, floorFunction.TileName));
            break;
        case SpawnEntityFunction spawnEntityFunction:
            screenModel.Entities.Add(new EntityModel(spawnEntityFunction.EntityIdentifier, spawnEntityFunction.SpawnPosition));
            break;
        case ScreenExitFunction screenExitFunction:
            screenModel.ScreenExits.Add(new ScreenExitModel(screenExitFunction.ConnectedScreenIdentifier, screenExitFunction.ExitDirection));
            break;
    }
}    
\end{lstlisting}

If the \texttt{functionInvocationNode} denotes an invocation of a \texttt{SizeFunction}, the map width and height will be set. If it denotes a \texttt{FloorFunction}, the a new instance of the \texttt{Floor} intermediate model will be added to the \texttt{ScreenModel}'s \texttt{TileStack}. It is much the same principle for adding new entities and \texttt{ScreenExit}s to the \texttt{ScreenModel}.

Now, if the visitor reaches an \texttt{ExitValueNode}, it will add that exit, too. This can be seen in code \snipref{lst:visitExitNodeSG}.

\begin{lstlisting}[label={lst:visitExitNodeSG}, caption={Visit \texttt{ExitValueNode}}, language=CSharp]
public void Visit(ExitValueNode exitValueNode)
{
    if (exitValueNode is TileExitValueNode tileExit)
    {
        DazelLogger.EmitWarning("TileExits have not been implemented yet.", tileExit.Token);
    }

    if (exitValueNode is ScreenExitValueNode screenExit)
    {
        screenModel.ScreenExits.Add(new ScreenExitModel(screenExit.ConnectedScreenIdentifier, screenExit.ExitDirection));
    }
}
\end{lstlisting}

While one might think that the code in \snipref{lst:finVisitSG} and \snipref{lst:visitExitNodeSG} might create the same exits, this is not the case. We avoid such conflicts because expressions have been evaluated before the code generation phase. This means that, exits that are created by an \texttt{Exit(...)} function and assigned to a variable are not created twice. The variable would denote an \texttt{TileExitValueNode}, which \snipref{lst:visitExitNodeSG} handles. Likewise, an exit that is created by a \texttt{ScreenExit(...)} function invocation is not created twice. It is only evaluated as a \texttt{FunctionInvocationNode}, which \snipref{lst:finVisitSG} handles.


The models generated by the aforementioned code-generating visitor will be used in the \dazel{} interpreter.