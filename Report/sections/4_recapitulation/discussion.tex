\chapter{Discussion} \label{chap:Discussion}
Our goal with this project was to design and implement a compiler for a programming language for beginners in the context of game development. 
This section seeks to communicate the circumstances under which the project was developed as well as give insight into our thoughts about the end result.
We also wish to elaborate on specific decisions that we, in retrospect, feel were poor or overly ambitious.

\section{Ambitiousness}
A major challenge in the first half of the project that ended up impacting the project as a whole was that our original group had a difference in ambition. 
One half of the group had lower expectations which caused conflicts and limited the group work.
Much time was spent attempting to solve these conflicts and getting everyone to agree on how much effort and time to invest in the project.
This combined with the overall level of ambition meant that we fell behind as not much work was being done on the project for the first two months. 
Eventually, this resulted in the decision to split our group in two halves as we were unable to find an agreeable compromise.

After the split, we decided to maintain the original vision for the project despite having less time and a smaller group. This unfortunately meant that we ended up investing too much time into features that we realistically did not have time to implement.

Furthermore, the consequence of the group split meant that we were unable to spend as much time as we would have liked on the game aspect of \dazel{}. 
Thus we ended with a relatively simple prototype, however we feel that we, under the circumstances, delivered a satisfying proof of concept.

\section{Learning Goals}
Part of the semester learning goals state that we should be able to demonstrate a working knowledge of all the phases of a compiler or interpreter. We feel that we succeeded in achieving this, but in hindsight it is very clear that there are areas in which we, as previously mentioned, may have been too ambitious. 

One particular feature that stands out as an immense technical challenge has been the implementation of member access. A large part of the difficulty with this feature has been finding helpful literature on how one could go about implementing such a feature and as a result a lot of time was spent making a solution that worked as one would expect. This was a valuable learning experience though and we were able to implement a feature that was important to our to language design despite it not being part of the curriculum.

Areas that may have been more fruitful to invest time into would have been the code generation phase of the compiler. Currently, we are only able to compile a few elements of our language into intermediate models, and we would have enjoyed having a more feature rich compiler that is able to handle control flow structures as well as boolean logic. This would have allowed us to construct games with a narrative and action which is more in line with what we hoped to achieve.

\section{Criteria evaluation}
A primary goal for us has been to construct the language in a fashion that ensures that it has a high level of readability and writability, as the language is intended for beginners. In addition, we also focused on making the language syntactically similar to languages such as C\# to make the transition from \dazel{} to any of the modern, more feature rich, languages easier. 

When taking a critical look at the language, we feel that we have succeeded in creating the foundation for these criteria to be met, as all the infrastructure is in place. 
We feel that the features that we did manage to implement lived up to the criteria, however we sadly did not have time to implement as many features as we would have liked despite allocating more time to the project than what is outlined in the semester description.

\section{Testing}
Our approach to testing could have been better. Rather than testing after the fact, we should have practiced something more alike the test-driven development methodology. This could have saved us valuable time later on in the project.
Because of the size reduction of the group, we had trouble managing our time properly and getting into a flow where everything was being worked on at once.
Consequently, when working on the project, only a few aspects was worked on at once.
This meant that we did not prioritize writing tests as much as we should have. Some tests were written quite late, which reduced their usefulness throughout the development of the project. This is especially true for the integration tests as there are certain elements we wished to have tested further. 
As mentioned in \secref{sec:IntTesting}, we could have implemented integration test between the phases of the compiler. This could have augmented our current test-suite. Additionally, creating tests which check that the error output corresponds to the expected output would also marginally improve the integration tests.
It turned out that it would have been useful to have more tests written at an earlier stage as we ended up discovering some major flaws near the deadline for the project, though we did end up addressing these either way even though we were short on time. 
Only near the end of the project did we feel that we had satisfactory coverage.

Despite all this, one thing we are quite happy with was our ability to set up an automated test workflow on our version control software such that new code would only be accepted if all tests passed.
Initially, we were easily able to set this up using and having our .NET project build and run the tests.
When we began working on the interpreter, we had trouble referencing and using the previously written code inside of Unity, so we decided to migrate all the source code.
However, after migrating, it proved much more difficult to set up this automated test workflow with Unity and it turned out to be a large time investment.
However, we ended up succeeding in setting up the workflow with Unity.
The result was that everything took place within Unity instead of having the project split in two while maintaining the security benefit from running automated tests before merging new code.
