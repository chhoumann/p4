\subsection{Scope}
In this section we describe different types of scope rules, specifically static scopes, block scopes and dynamic scopes.
We will ultimately use this to determine the best fit for \dazel{}.

\subsubsection{Static Scopes}
Originally introduced by ALGOL 60, \texttt{static scoping} is the act of binding names to nonlocal variables such that the scope of a variable
can be determined prior to program execution. This way, one can determine the type of every variable via the source code.
Static-scoped languages can be split into two categories: those that allow sub-programs to be nested and those that do not.
The former creates nested static scopes while the latter only creates nested scopes through nested class definitions and blocks. 
Static scope rules are quite commonly used in modern languages due to their emphasis on static type checking. \cite{sebesta_concepts_2016}

\subsection{Dynamic Scopes}
In stark contrast to static scoping, variables declared in languages with \texttt{dynamic scoping} are determined at runtime through the calling sequence of subprograms.

\begin{lstlisting}[caption={Example of dynamic scoping}, label={lst:DynamicScopeExample}]
function main() {
	function nested1() {
		var x = 7;
	}
	
	function nested2() {
		var y = x;
	}

	var x = 3;
}
\end{lstlisting}

In listing \ref{DynamicScopeExample}, assuming that dynamic scoping rules apply, the meaning of the identifier \texttt{x} cannot be determined at compile time.
Specifically, the declaration of an identifier is first searched for in the local function. 
If no declaration for \texttt{x} is found, the search continues to the function's caller, its \texttt{dynamic parent}, and so on up the call-stack.

\subsubsection{Blocks}
The powerful concept of block scoping allows specific sections of code called blocks to have their own localized variables. 
Variables declared within a block are local, meaning they cannot be accessed from outside the scope. However, nested blocks can still access variables from outer scopes.
A variable declaed within a block is allocated when the block is entered and deallocated when it is exited.
