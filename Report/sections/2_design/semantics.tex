\section{Semantics for Dazel}

In this section we will be presenting, in an informal manner, the semantics of \dazel.
Firstly, we will present the type rules which is then followed by a presentation of the scope rules.

\subsection*{Type checking}



\subsection*{Type rules}
\dazel has implicitly declared strongly types.
This means the programmer does not need to explicitly define the type of every variable, however, once declared, a variable
cannot dynamically change type.
For example, as can be seen in \ref{lst:IllegalAssignment}, \textbf{Exit1} is declared to be of type \textbf{Exit} so it cannot be be
assigned to an integer afterwards.

\begin{lstlisting}[caption={Example of an illegal assingment}, label={lst:IllegalAssignment},escapechar=|]
// ./Screens/SampleScreen1.txt
Screen SampleScreen1 
{
	Exits 
	{
		Exit1 = Exit([4, 0], SampleScreen2.Exit1);
		Exit1 = 1; // Not legal because Exit1 has type Exit
	}
}
\end{lstlisting}

The decision to use this system is based on the fact that strongly typed languages offer greater safety, however being required to
specify the type of each variable as part of its declaration is often confusing to beginners as mentioned in \secref{sec:scientific_research}.
Therefore it was decided to go with a hybrid approach.

\subsection*{Type checking}

Because \dazel is a strongly typed language, and the goal is to offer safety and ease of use, we decided to perform type checking at compile time - that is, to make it
statically typed.