\section{Structural Operational Semantics}
In the following, we will describe how one can use a structural operational semantics to define a transitions system for a language - that is, we are only concerned with the behavior of a program.
We will then use this to give a formal definition of the semantics for \dazel{}.

\subsection{Big- and small-step semantics}
Big- and small-step semantics are two different kinds of operational semantics used describe computations.
Given a single transition $\gamma \rightarrow \gamma' $, big-step semantics describes the entire computation where $\gamma$ is the start configuration and $\gamma'$ must be a terminal configuration. 
In contrast, a small semantics describes only a single step in a larger computation in which $\gamma'$ does not need to be a terminal configuration. 
\Figref{SSS_and_BSS} illustrates the difference between the two types of operational semantics\cite{huttelTransitionsTreesIntroduction2010}.

\fig{0.75}{SSS_and_BSS}{The difference between big- and small-step semantics illustrated\cite{huttelTransitionsTreesIntroduction2010}.}

We have opted to give a big-step semantics for \dazel{} as the simplicity of the language does not facilitate the need to describe every individual computation in detail.  
\subsubsection*{Abstract Syntax}
An abstract syntax is a description of a programs' structure that is used to represent its behavior. 
The abstract syntax of a given language contains a collection of syntactic categories. 
For each of these, we give a finite set of formation rules that define how each item in the category can be constructed.
\Figref{AbstractSyntax} shows the abstract syntax \dazel{}.


\begin{figure}[htbp]
	\centering
	\textit{Syntatic categories}
	\vspace{4mm}


	\begin{tabular}{l l}
		$a \in \textbf{ArithmExp}$ & $\text{Arithmetic expressions}$ \\ 
		$n \in \textbf{Num}$ & $\text{Numerals}$ \\
		$x \in \textbf{Var}$ & $\text{Variables}$ \\
		$A_v \in \textbf{AssignV}$ & $\text{Variable assignments}$ \\
		$D_v \in \textbf{DeclV}$ & $\text{Variable declarations}$ \\
		$C_m \in \textbf{ContDecl}$ & $\text{Content declarations}$ \\
		$S \in \textbf{Stm}$ & $\text{Statements}$
	\end{tabular}

	\vspace{4mm}
	\textit{Formation rules}
	\begin{align*}
		S&::=x=a\mid \texttt{skip}\mid S_1;S_2\mid \texttt{repeat }\{S\}; \\
		a&::=n\mid x\mid a_1+a_2\mid a_1-a_2\mid a_1*a_2\mid a_1/a_2\mid (a_1) \\
		%VList&::=[a]\mid [a_1, \ldots, a_n]\mid [\epsilon] \\
		GOName&::= \texttt{Screen} \texttt{ Id } \{GOCont\} \mid \texttt{Entity} \texttt{ Id } \{GOCont\} \mid \texttt{MovePattern} \texttt{ Id } \{GOCont\} \\
		GOCont&::= \texttt{Map} \{S\} \mid \texttt{Exits} \{S\} \mid \texttt{Entities} \{S\} \mid \texttt{OnScreenEntered} \{S\} \mid \texttt{Data} \{S\}
	\end{align*}

	\caption{Abstract syntax for \dazel{}.}
	\label{fig:AbstractSyntax}
\end{figure}

\subsubsection*{Transition rules}

For the language \dazel{} we have, as previously mentioned, decided to describe the language in terms of Big-step semantics since we are only interested in describing the relationship between the initial and the final state of an execution\cite{SemanWithApplications}.

\textbf{Arithmetic expressions}
The transition rules in \figref{fig:BssArithm} describe the semantics for arithmetic expressions in \dazel{}. It was decided that the semantics for arithmetic expression should follow a simple c

\begin{figure}[htbp]
	\centering
	\begin{gather*}
		[PLUS_\text{BSS}] 
		\qquad \dfrac
		{\envs \vdash a_1 \rightarrow_a v_1 \; \envs \vdash a_2 \rightarrow_a v_2}
		{\envs \vdash a_1 + a_2 \rightarrow_a v}
		\qquad \text{ where }v = v_1 + v_2
		\\
		% 
		\\
		[MINUS_\text{BSS}] 
		\qquad \dfrac
		{\envs \vdash a_1 \rightarrow_a v_1 \; \envs \vdash a_2 \rightarrow_a v_2}
		{\envs \vdash a_1 - a_2 \rightarrow_a v}
		\qquad \text{ where }v = v_1 - v_2
		\\
		% 
		\\
		[MULTIPLY_\text{BSS}] 
		\qquad \dfrac
		{\envs \vdash a_1 \rightarrow_a v_1 \; \envs \vdash a_2 \rightarrow_a v_2}
		{\envs \vdash a_1 * a_2 \rightarrow_a v}
		\qquad \text{ where }v = v_1 \cdot v_2
		\\
		% 
		\\
		[DIVIDE_\text{BSS}] 
		\qquad \dfrac
		{\envs \vdash a_1 \rightarrow_a v_1 \; \envs \vdash a_2 \rightarrow_a v_2}
		{\envs \vdash a_1 / a_2 \rightarrow_a v}
		\qquad \text{ where }v = \dfrac{v_1}{v_2}
		\\
		% 
		\\
		[PARENTHESES_\text{BSS}] 
		\qquad \dfrac
		{\envs \vdash a_1 \rightarrow_a v_1}
		{\envs \vdash (a_1) \rightarrow_a v_1}
		\\
		% 
		\\
		[NUM_\text{BSS}] 
		\qquad envs \vdash n \rightarrow_a v
		\qquad \text{ if } \mathbb{R}[\![n]\!] = v \quad \text{Where } \mathcal{R}:\textbf{Num}\rightarrow \mathbb{R}
		\\
		% 
		\\
	\end{gather*}
	\caption{Big-step transition rules for \textbf{ArithmExp}.}
	\label{fig:BssArithm}
\end{figure}

\textbf{Variable and procedure declaration }
To ensure that we have static scope rules for both variable and procedure declarations we define $Env_V$ and $Env_P$ respectively in \figref{EnvDef}:

\begin{figure}[htbp]
	\centering
	\begin{tabular}{l l}
		$Env_P = Pname \hookrightarrow Stm \; x \; Env_V \; x \; Env_P$
	\end{tabular}
	\caption{Procedure environment}
	\label{fig:EnvDef}
\end{figure}

\begin{figure}[htbp]
	\centering
	\begin{gather*}
		[VAR_\text{BSS}]
		\qquad 
		\frac
		{\langle D_v,\; env_V[x \mapsto l], \; sto[l \mapsto v][next \mapsto \text{ new } l]\rangle \rightarrow_D (env'_V, sto')}
		{\langle x:=a; D_V, env_V, sto \rangle \rightarrow_D (env'_V, sto')} \\
		\text{where } v = \mathcal{A}[\![a]\!](sto\circ env_V ) \text{ and } l = \textit{sto } \texttt{next}
		\\
	\end{gather*}
	\caption{Big-step transition rules for \textbf{Variable declarations}.}
	\label{fig:BssStm}
\end{figure}

\begin{figure}[htbp]
	\centering
	\begin{gather*}
		[ASSIGNMENT_\text{BSS}] 
		\qquad env_V, env_P \vdash \langle x:=a,sto\rangle \rightarrow sto[l\mapsto v] \\
		\qquad \text{ where } l = env_V \; x \; and \; v = \mathcal{A}[\![a]\!](sto\circ env_V )
		\\
		% 
		\\
		[COMPOUND_\text{BSS}] 
		\qquad \dfrac
		{env_V, env_P \vdash \langle S_1, sto \rangle \rightarrow sto'' \;\langle S_2, sto'' \rangle \rightarrow sto'}
		{\langle S_1;S_2,sto \rangle\rightarrow sto'}
		\\
		% 
		\\
		[REPEAT_\text{BSS}] 
		\qquad \dfrac
		{\langle S_1, sto \rangle \rightarrow sto'' \;\langle \texttt{repeat} \{S\}, sto \rangle \rightarrow sto'}
		{\langle S_1 \texttt{;repeat} \{S\}, sto \rangle\rightarrow sto'}
		\\
		% 
		\\
		[Block_\text{BSS}] 
		\qquad \frac
		{
			\begin{gathered}
				\langle D_V, env_V, sto\rangle \rightarrow_{D} (\text{env'}_V, sto') \\ 
				env'_V, env'_P \vdash \langle S, sto'\rangle \rightarrow sto''
			\end{gathered}
		}
		{env'_V, env'_P \vdash \langle L_\text{Brace} \; D_V \; D_P \; S \; R_\text{Brace}, \; sto\rangle\rightarrow sto''}
		\\
		% 
		\\
	\end{gather*}
	\caption{Big-step transition rules for \textbf{Stm}.}
	\label{fig:BssStm}
\end{figure}

\begin{figure}[htbp]
	\centering
	\begin{gather*}
		[GAMEOBJECT_\text{BSS}] 
		\qquad \dfrac
		{\langle D_{co}, env_v, sto\rangle \rightarrow_{DCO} (\text{env'}_{CO}, sto'')}
		{env_{CO} \vdash \langle GOName \; Id \; \{D_{CO}\}, sto\rangle\rightarrow sto'}
		\\
		% 
		\\
		[CONTENT_\text{BSS}] 
		\qquad \frac
		{
			\begin{gathered}
				\langle D_V, env_v, sto\rangle \rightarrow_{DV} (\text{env'}_V, sto'') \\ 
				env'_V \vdash \langle S, sto''\rangle \rightarrow sto'
			\end{gathered}
		}
		{\langle GOCont \{S\}, s\rangle\rightarrow s'}
		\\
		% 
		\\
	\end{gather*}
	\caption{Big-step transition rules for \textbf{ContDecl}.}
	\label{fig:BssStm}
\end{figure}


\subsubsection*{Transition System}

For our operational semantics we have a transition system defined for each expression and declaration. 
The structure for the transition system will be a triple $(\Gamma,\rightarrow,T)$ where $\Gamma$ is a set of configurations, $\rightarrow$ is the transition relation, which is a subset of $\Gamma\times\Gamma$, and $T\subseteq \Gamma$ is a set of terminal configurations. \cite{huttelTransitionsTreesIntroduction2010}

The definition of the transition system for each expression type in \dazel{} is shown in \figref{TSAexp}, \figref{TSBexp}, \figref{TSDecv} and \figref{TSDecp}. 
\begin{figure}[htbp]
	\begin{gather*} 
		\{ \Gamma_\text{AExp}, \rightarrow_a, T_\text{Aexp} \} \\ 
		\textit{Configurations: } \Gamma_\text{Aexp} = \text{Aexp} \cup \mathbb{R} \\ 
		\textit{Terminal configurations: } T_\text{Aexp} = \mathbb{R}
	\end{gather*}
	\caption{Transition system for arithmetic expressions}
	\label{fig:TSAexp}
\end{figure}

\begin{figure}[htbp]
	\begin{gather*} 
		\{ \Gamma_\text{BExp}, \rightarrow_a, T_\text{Bexp} \} \\ 
		\textit{Configurations: } \Gamma_\text{Bexp} = \text{Bexp} \cup \{tt, f\!f\} \\ 
		\textit{Terminal configurations: } T_\text{Bexp} = \{tt, f\!f\}
	\end{gather*}
	\caption{Transition system for boolean expressions}
	\label{fig:TSBexp}
\end{figure}

\begin{figure}[htbp]
	\begin{gather*} 
		\{ \Gamma_\text{Dv}, \rightarrow_a, T_\text{Dv} \} \\ 
		\textit{Configurations: } \Gamma_\text{Dv} = (Dec_v \times Env_v \times sto) \cup Env_v \times sto \\ 
		\textit{Terminal configurations: } T_{\text{Dec}_v} = Env_v \times sto
	\end{gather*} 
	\caption{Transition system for variable declaration}
	\label{fig:TSDecv}
\end{figure}

\begin{figure}[htbp]
	\begin{gather*} 
		\{ \Gamma_\text{Dp}, \rightarrow_a, T_\text{Dp} \} \\ 
		\textit{Configurations: } \Gamma_\text{Dp} = (Dec_p \times Env_p) \cup Env_p \\ 
		\textit{Terminal configurations: } T_\text{Dp} = Env_p
	\end{gather*} 
	\caption{Transition system for procedure}
	\label{fig:TSDecp}
\end{figure}

\subsubsection*{Syntactic Categories}
\subsubsection*{Formation Rules}
\subsubsection*{Big Step Semantic Rules For \dazel{}}