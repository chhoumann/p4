\chapter{Language design}
This chapter details the design of \dazel.
The language is intended to be a transitional language from visual programming to high-level language. Based on the problem analysis, it has been possible to specify the design for the user.
The target group is beginners in programming who are younger people. Therefore a programming language to make computer games has been built. This has been chosen as young people can relate more to video games as their hobby. \fxfatal{Kunne godt uddybes en del:
"This has been chosen as young people can relate more to video games as their hobby" - skrev vi ikke lidt om det her i starten? måske lidt at hente derfra.
Men i hvert fald en kilde på at understøtte påstanden. - John's review on PR}
This will help them to understand the principles of how a game should work more easily, and therefore be able to start programming. \fxfatal{Maybe give an example of what principles? - John's review on PR}
It was decided to develop a language inspired by the game "the Legend of Zelda: Link’s Awakening" into the programming language, as it is a familiar game with basic game terminologies.
This helps to set a framework for what the program language should be capable of.
In addition, "Unity" has been used as a program to test different functions to find out what could work well for the program language.


\fxfatal{Introduction to language design chapter}

\section{Code examples}

\begin{lstlisting}[caption={Example screen}, label={lst:SampleScreen1},escapechar=|]
// ./Screens/SampleScreen1.txt
Screen SampleScreen1 
{
    Map 
    {
        Size(30, 24);

        Walls(Stone); 
        Floor(Grass);

        Line(TopLeft, TopRight, Cliff);
        Line([2, 2], [2, 4], Cliff);

        Square(position, size, Cliff);
        Square([8, 8], 4, Cliff);
    }

    OnScreenEntered
    {
        if Player.CompletedQuest(...) 
        {
            SetTile([4, 0], Stair);
        }
    }

    Entities
    {
        SpawnEntity(Skeleton1, [4, 4]).SetMovePattern(Square1);
    }
    
    Exits 
    {
        // Two different ways to create an exit
        // Specific tile(s) or whole screen side
        Exit1 = Exit([4, 0], SampleScreen2.Exit1);
        ScreenExit(Bottom, SampleScreen2);
    
        // COULD HAVE: Floor exits that lead to another screen at the same normalized 
        // coordinate |\fxfatal{Remove if we don't make FloorExits}|
        FloorExits(  
            [ 
                [4, 0] 
                [5, 0], 
                [9, 0], 
                [10, 0] 
            ],
            SampleScreen2
        )
    }
}
\end{lstlisting}

Code snippet~\ref{lst:SampleScreen1} gives an example of a screen. The contents thereof are explained below.

\section{Language design - sprint 1}
% We have not discussed whether we represent changes in our language over time or not.

To start designing the programming language, we set out to specify a minimum viable product (MVP). We decided to start small but with expansion in mind.

\subsection{Keywords}
These are the reserved keywords that have been used.  A convention has been introduced that defines all block-indicators\fxfatal{What do we call them? We have a semi-convention, but there is nothing to completely tie them together. Should we have a proper convention here?} to be denoted by an upper-case first character.

\begin{multicols}{4}
    \begin{enumerate}
        \item \texttt{repeat}\label{itm:repeat}
        \item \texttt{until}\label{itm:until}
        \item \texttt{or}\label{itm:or}
        \item \texttt{and}\label{itm:and}
        \item \texttt{forever}\label{itm:forever}
        \item \texttt{Create}\label{itm:Create}
        \item \texttt{Screen}\label{itm:Screen}
        \item \texttt{Entity}\label{itm:Entity}
        \item \texttt{MovePattern}\label{itm:MovePattern}
        \item \texttt{Exit}\label{itm:Exit}
        \item \texttt{ScreenExit}\label{itm:ScreenExit}
        \item \texttt{FloorExit}\label{itm:FloorExit}
        \item \texttt{Player}\label{itm:Player}
    \end{enumerate}
\end{multicols}

\ref{itm:repeat} indicates a loop. It is followed by \ref{itm:until} and expression, which can contain \ref{itm:or} or \ref{itm:and}. Otherwise, it is followed by \ref{itm:forever}, which indicates a never-ending loop.

\ref{itm:Create} is used to create a new instance. It is almost synonymous with \verb|new| in other languages.

\ref{itm:Screen} denotes a screen block, which is a container for other blocks like \verb|Map|, \verb|OnScreenEntered|, \verb|Entities|, and \verb|Exits|.

\ref{itm:Entity} is a block used to define what an entity is and what it does.

\ref{itm:MovePattern} is a block used to define a move pattern which can be applied to an entity.

\ref{itm:Exit}, \ref{itm:ScreenExit}, and \ref{itm:FloorExit} denotes exits or transitions to other screens. These are usually triggered by player movement.

\ref{itm:Player} is globally accessible and always points to the player. This allows the programmer to create interactions involving the player. \fxfatal{unsure about how to describe this since there is nothing to describe at the moment - we do not have anything implemented}
    
\subsection{Built-in functionality}
These are also keywords, but they represent library-like functions that a user can use to manipulate data. Explanations of these can be seen in \tabref{table:explanations_of_functions}.\fxfatal{Make sure these explanations are up to date with the implementation.}
\begin{table}[h!]
    \centering
        \begin{tabular}{ l p{4.5cm} p{4cm} }
            \hline
            \textbf{Function} & \textbf{Explanation} & \textbf{Example} \\
            \hline
            \texttt{Size} 
            & Sets the size of the map.
            & \texttt{Size(30, 24)} \\\hline
            \texttt{Walls} 
            & Sets the outermost tiles on each side of the map to a certain tile type.
            & \texttt{Walls(Stone)} \\\hline
            \texttt{Floor} 
            & Sets the floor layer of each tile to be of a certain tile type.\fxfatal{Do we still use layers?}
            & \texttt{Floor(Grass)} \\\hline
            \texttt{Line} 
            & Creates a line of a certain tile type. Takes two coordinates denoting a start and end, as well as the tile type desired.
            & \texttt{Line([2, 2], [2, 4], Stone)} \\\hline
            \texttt{Square} 
            & Creates a square of a certain tile type. Takes a coordinate of the center position, a size, and a tile type.
            & \texttt{Square([8, 8], 4, Stone)} \\\hline
            \texttt{MoveLeft} 
            & Moves entity one tile left. This is used when specifying a MovePattern.
            & \texttt{MoveLeft()} \\\hline
            \texttt{MoveRight} 
            & Moves entity one tile right. This is used when specifying a MovePattern.
            & \texttt{MoveRight()} \\\hline
            \texttt{MoveDown} 
            & Moves entity one tile down. This is used when specifying a MovePattern.
            & \texttt{MoveDown()} \\\hline
            \texttt{MoveUp} 
            & Moves entity one tile up. This is used when specifying a MovePattern.
            & \texttt{MoveUp()} \\\hline
            \texttt{PlayerInAggroRange} 
            & Can only be called within a scope for an entity. Checks if the player is in aggro range for the given entity and returns a boolean representing the result of this check.\fxfatal{Should this be in the CFG? Or change it?}
            & \texttt{PlayerInAggroRange()} \\\hline
        \end{tabular}
        \caption{Explanations of built-in functionalities}
        \label{table:explanations_of_functions}
\end{table}

    
\subsection{Statement Level Control Structures}
Users can change execution flow using control structures. These are if-statements and repeat-statements.
\subsubsection{If statements}
If statements are selection statements. These provide the means of choosing between two or more execution paths in a program\cite{sebesta_concepts_2016}.

In Dazel, if-statements are followed by an expression and then curly braces, which open a new scope. The statements within this scope are executed if the expression holds true.

\begin{lstlisting}[caption={Example of an if statement}, label={lst:ifexpression},escapechar=|]
if <expression>|\label{lst:exp}|
{
    Code...
}
\end{lstlisting}

In \ref{lst:ifexpression} on line \ref{lst:exp},  \verb|<expression>| denotes a placeholder expression.

\subsubsection{Repeat loops}
Repeat loops are iterative statements.

\begin{lstlisting}[caption={Example of loops}, label={lst:loops},escapechar=|]
repeat until <var> == 10|\label{lst:repeatuntil}|
{
    Code...
}

repeat forever|\label{lst:repeatforever}|
{
    Code...
}
\end{lstlisting}\fxfatal{Specify order of evaluation - once we've figured it out. See feedback 17/03}

In \ref{lst:loops} on line \ref{lst:repeatuntil}, \verb|<var>| denotes an arbitrary variable. It is expected that the expression will evaluate to true, otherwise the loop does the same as the \verb|repeat forever| loop on line \ref{lst:repeatforever}.

The \verb|repeat forever| loop repeats forever - or until the running instance terminates.
The \verb|repeat until| loop repeatedly executes the code in the scope immediately below it until the given expression evaluates to \verb|true|.
\fxfatal{Consider not using the 'forever' keyword. It might be redundant as compared to just 'repeat'}

\subsection{Operator symbols}
\fxfatal{Work in progress. Should this be here?}
See \tabref{table:operatorsymbols}.

\begin{table}[h!]
    \centering
    \begin{tabular}{ |c|c|c||c|c|c|c| }
        \hline
        \textbf{Category} & \textbf{Operator} & \textbf{Associativity} & \texttt{Number} & \texttt{String} & \texttt{Boolean} & \texttt{Tile} \\                              
        \hline

        \multirow{6}{*}{Relational} 
        & \texttt{<}
        & $\rightarrow$ 
        & Type1 
        & Type2 
        & Type3 
        & Type4 
        \\
        
         
        & \texttt{>} 
        & $\rightarrow$ 
        & Type1 
        & Type2 
        & Type3 
        & Type4 
        \\

        
        & \texttt{==} 
        & $\rightarrow$ 
        & Type1 
        & Type2 
        & Type3 
        & Type4 
        \\

         
        & \texttt{!=} 
        & $\rightarrow$ 
        & Type1 
        & Type2 
        & Type3 
        & Type4 
        \\

         
        & \texttt{>=} 
        & $\rightarrow$ 
        & Type1 
        & Type2 
        & Type3 
        & Type4 
        \\

         
        & \texttt{<=} 
        & $\rightarrow$ 
        & Type1 
        & Type2 
        & Type3 
        & Type4 
        \\\hline

        \multirow{2}{*}{Logic}
        & \texttt{and} 
        & $\rightarrow$ 
        & Type1 
        & Type2 
        & Type3 
        & Type4 
        \\
 
        & \texttt{or} 
        & $\rightarrow$ 
        & Type1 
        & Type2 
        & Type3 
        & Type4 
        \\\hline
        
        Assignment 
        & \texttt{=}
        & $\leftarrow$ 
        & Type1 
        & Type2 
        & Type3 
        & Type4 
        \\\hline
        
        \multirow{4}{*}{Arithmetic} 
        & \texttt{+}
        & $\rightarrow$ 
        & Type1 
        & Type2 
        & Type3 
        & Type4 
        \\
        
         
        & \texttt{-}
        & $\rightarrow$ 
        & Type1 
        & Type2 
        & Type3 
        & Type4 
        \\
         
        & \texttt{*} 
        & $\rightarrow$ 
        & Type1 
        & Type2 
        & Type3 
        & Type4 
        \\
         
        & \texttt{/}
        & $\rightarrow$ 
        & Type1 
        & Type2 
        & Type3 
        & Type4 
        \\\hline
    \end{tabular}
    \caption{Operation symbols}
    \label{table:operatorsymbols}
\end{table}

\fxfatal{Fix types. Depends on implementation.}